<!-- Generated by SpecStory -->

# Understanding video segment view data (2025-07-05 00:54Z)

_**User**_

Next, I want to plan a 'video segment' view. this view will display the video segments created from the user's uploaded video. In the "my videos" view the user sees the videos associated with thier account.

First, help me understand how the app is populating the grid view. What database table or tables does the data come from?

---

_**Assistant**_

I'll help you understand how the app populates the grid view and identify the database tables involved. Let me start by examining the video-related components and services.

---

<details>
            <summary>Searched codebase "VideoService loadUserVideos database table" ‚Ä¢ **8** results</summary>
        
| File | Lines |
|------|-------|
| `terraform/admin-lambda/admin.js` | L186-213 |
| `backend/dynamodb_service.py` | L107-143 |
| `src/components/admin/AdminVideosPanel.vue` | L279-315 |
| `src/stores/admin.ts` | L139-156 |
| `src/components/admin/AdminUserVideosPanel.vue` | L336-423 |
| `src/components/admin/AdminUserVideosPanel.vue` | L243-279 |
| `src/components/admin/AdminUserVideosPanel.vue` | L209-243 |
| `src/components/admin/AdminUserVideosPanel.vue` | L121-146 |

</details>

---

Now let me look at the videos store to understand how it loads user videos:

---

Read file: src/stores/videos.ts

---

Now let me examine the VideoService to understand the API endpoints and data structure:

---

Read file: src/core/services/VideoService.ts

---

Let me see the rest of the VideoService, particularly the `getAIVideoMetadataList` method:

---

Read file: src/core/services/VideoService.ts

---

Now let me check the backend API configuration to understand the endpoints:

---

Read file: src/core/config/config.ts

---

Now let me check the backend DynamoDB service to understand the database structure:

---

Read file: backend/dynamodb_service.py

---

Now let me check the Terraform configuration to understand the DynamoDB table structure:

---

<details>
            <summary>Searched codebase "dynamodb.tf" ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

<details>
            <summary>Grep search for "DYNAMODB_TABLE_NAME" ‚Ä¢ **14** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_CONFIGURATION_SOLUTION.md` | L138 | `DYNAMODB_TABLE_NAME=your-dynamodb-table` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_DEPLOYMENT_STEPS.md` | L26 | `DYNAMODB_TABLE_NAME=easy-video-share-video-metadata` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_DEPLOYMENT_STEPS.md` | L108 | `DYNAMODB_TABLE_NAME=easy-video-share-video-metadata` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/Ai-BRoll-Short-Form-Video-Generation-Plan.md` | L120 | `- _LLM Context:_ `import boto3`, `from datetime import datetime`, `from typing import List, Dict, Any`, `DYNAMODB_TABLE_NAME = "your-project-name-video-metadata"`. Provide `dynamodb_resource = boto3.resource('dynamodb')` and `table = dynamodb_resource.Table(DYNAMODB_TABLE_NAME)`. Give function signatures with docstrings. Ensure `update_job_status` can handle status changes and adding `output_s3_urls` as a list.` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/scripts/deploy-railway.sh` | L28 | `echo "DYNAMODB_TABLE_NAME=easy-video-share-video-metadata"` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_TWO_SERVICE_SETUP.md` | L27 | `DYNAMODB_TABLE_NAME=your-dynamodb-table` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_DEPLOYMENT_GUIDE.md` | L76 | `- `DYNAMODB_TABLE_NAME` - DynamoDB table name` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_DEPLOYMENT_GUIDE.md` | L85 | `- `DYNAMODB_TABLE_NAME` - DynamoDB table name` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_DEPLOYMENT.md` | L36 | `DYNAMODB_TABLE_NAME=easy-video-share-video-metadata` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/scripts/setup-railway-worker.sh` | L49 | `echo "- DYNAMODB_TABLE_NAME"` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/terraform/outputs.tf` | L36 | `output "dynamodb_table_name" {` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/backend/config.py` | L14 | `DYNAMODB_TABLE_NAME: str = "easy-video-share-video-metadata"` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/backend/dynamodb_service.py` | L11 | `DYNAMODB_TABLE_NAME = os.getenv("DYNAMODB_TABLE_NAME", "easy-video-share-video-metadata")` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/backend/dynamodb_service.py` | L18 | `table = dynamodb.Table(DYNAMODB_TABLE_NAME)` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/terraform/RESOURCE-TRANSITION-STRATEGY.md` | L294 | `aws dynamodb describe-table --table-name $(terraform output dynamodb_table_name)` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/RAILWAY_DEPLOYMENT.md` | L36 | `DYNAMODB_TABLE_NAME=easy-video-share-video-metadata` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/scripts/setup-railway-worker.sh` | L49 | `echo "- DYNAMODB_TABLE_NAME"` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/backend/README-SPRINT-5-AWS-DEPLOYMENT.md` | L326 | `name  = "DYNAMODB_TABLE_NAME"` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/backend/README-SPRINT-5-AWS-DEPLOYMENT.md` | L424 | `name  = "DYNAMODB_TABLE_NAME"` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/backend/README-SPRINT-5-AWS-DEPLOYMENT.md` | L601 | `DYNAMODB_TABLE_NAME=easy-video-share-video-metadata` |

</details>

---

Let me check the Terraform configuration to understand the DynamoDB table structure:

---

<details>
            <summary>Listed directory terraform ‚Ä¢ **30** results</summary>
        
| Name |
|-------|
| üìÑ `BRANCH-RESOURCE-MANAGEMENT-PLAN.md` |
| üìÑ `README-RESOURCE-MANAGEMENT.md` |
| üìÑ `README.md` |
| üìÑ `RESOURCE-TRANSITION-STRATEGY.md` |
| üìÑ `main.tf` |
| üìÑ `s3-permissions.tf` |
| üìÑ `admin_lambda_function.zip` |
| üìÑ `lambda_function.zip` |
| üìÑ `terraform.tfvars` |
| üìÑ `.terraform.lock.hcl` |
| üìÅ `.terraform` |
| üìÅ `scripts` |
| üìÅ `terraform.tfstate.d` |
| üìÑ `sudo apt update && sudo apt install terra` |
| üìÑ `Fargate Implementation Plan Sprints.md` |
| üìÑ `TESTING.md` |
| üìÅ `admin-lambda` |
| üìÅ `analysis` |
| üìÅ `backups` |
| üìÑ `import-test.plan` |
| üìÑ `index.html` |
| üìÅ `lambda` |
| üìÑ `old_main_tf.txt` |
| üìÑ `outputs.tf` |
| üìÑ `transition.plan` |
| üìÑ `variables.tf` |
| üìÑ `terraform_1.12.2_linux_amd64.zip` |
| üìÑ `LICENSE.txt` |
| üìÑ `terraform` |

</details>

---

<details>
            <summary>Grep search for "resource "aws_dynamodb_table"" ‚Ä¢ **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/AI-Video-Generation-Pipeline-Plan.md` | L166 | `resource "aws_dynamodb_table" "audio_projects" {` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/AI-Video-Generation-Pipeline-Plan.md` | L205 | `resource "aws_dynamodb_table" "transcripts" {` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/AI-Video-Generation-Pipeline-Plan.md` | L233 | `resource "aws_dynamodb_table" "scene_beats" {` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/AI-Video-Generation-Pipeline-Plan.md` | L267 | `resource "aws_dynamodb_table" "generated_assets" {` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/terraform/old_main_tf.txt` | L212 | `resource "aws_dynamodb_table" "video_metadata" {` |
| `vscode-remote://wsl%2Bubuntu/home/maceo/easy-video-share-vue/terraform/main.tf` | L150 | `resource "aws_dynamodb_table" "video_metadata" {` |

</details>

---

Read file: terraform/main.tf

---

Now let me check the backend API endpoints to understand how the data flows:

---

<details>
            <summary>Searched codebase "FastAPI videos endpoint /api/videos" ‚Ä¢ **9** results</summary>
        
| File | Lines |
|------|-------|
| `backend/dynamodb_service.py` | L107-143 |
| `backend/dynamodb_service.py` | L143-177 |
| `backend/video_processing_utils.py` | L206-229 |
| `backend/video_processing_utils.py` | L229-249 |
| `backend/main_no_redis.py` | L1-64 |
| `backend/video_processing_utils_robust.py` | L185-197 |
| `backend/video_processing_utils_robust.py` | L135-185 |
| `backend/robust_video_processor.py` | L136-147 |
| `backend/robust_video_processor.py` | L147-188 |

</details>

---

Let me check the main FastAPI application to see the videos endpoint:

---

<details>
            <summary>Searched codebase "main.py" ‚Ä¢ **10** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

Read file: backend/main.py

---

Let me see the videos endpoint specifically:

---

Read file: backend/main.py

---

Based on my analysis of the codebase, I can now provide you with a comprehensive understanding of how the app populates the grid view and the database structure involved.

## How the App Populates the Grid View

The "My Videos" grid view is populated through the following data flow:

### 1. **Database Table Structure**

The app uses a **single DynamoDB table** called `easy-video-share-video-metadata` with the following structure:

**Primary Key:**

- `video_id` (String) - Primary hash key: `userId_timestamp_random`

**Global Secondary Index (GSI):**

- `user_id-upload_date-index` - Hash key: `user_id`, Range key: `upload_date`

**Key Fields:**

- `video_id` - Unique identifier for each video
- `user_id` - Cognito user sub (UUID)
- `user_email` - Display email
- `title` - Video title
- `filename` - Original filename
- `bucket_location` - S3 object key for original video
- `upload_date` - ISO timestamp
- `file_size` - File size in bytes
- `content_type` - MIME type
- `duration` - Video duration in seconds
- `created_at` - ISO timestamp
- `updated_at` - ISO timestamp
- `status` - Job status (QUEUED, PROCESSING, COMPLETED, FAILED)
- `output_s3_urls` - Array of S3 keys for processed video segments
- `error_message` - Error message if job failed

### 2. **Data Flow for Grid Population**

1. **Frontend Request**: The `Videos.vue` component calls `videosStore.loadUserVideos()`

2. **Store Action**: The videos store calls `VideoService.getAIVideoMetadataList()`

3. **API Call**: This makes a GET request to the FastAPI backend at `/api/videos`

4. **Backend Processing**: The FastAPI endpoint calls `dynamodb_service.list_videos(user_id)`

5. **Database Query**: Uses the GSI `user_id-upload_date-index` to query videos by user_id

6. **Data Transformation**: The backend transforms DynamoDB items to match the `VideoMetadata` interface expected by the frontend

### 3. **Key API Endpoints**

- **Frontend ‚Üí Backend**: `GET /api/videos` (FastAPI backend)
- **Backend ‚Üí DynamoDB**: Uses the `user_id-index` GSI to query by user_id
- **Data Source**: Single DynamoDB table `easy-video-share-video-metadata`

### 4. **Video Segments Data**

The `output_s3_urls` field in the database contains an array of S3 keys pointing to the processed video segments. Each video can have multiple segments after AI processing.

## Planning the Video Segment View

For your video segment view, you'll want to:

1. **Create a new route** like `/videos/{video_id}/segments`
2. **Add a new component** to display individual segments
3. **Use the existing `output_s3_urls` field** from the database to get segment information
4. **Leverage the existing `VideoService.getVideoUrl()` method** to get presigned URLs for each segment

The database structure already supports this since each video record contains:

- `output_s3_urls` - Array of processed segment S3 keys
- `status` - Processing status to show if segments are ready
- `error_message` - Any processing errors

Would you like me to help you implement the video segment view component next?

---

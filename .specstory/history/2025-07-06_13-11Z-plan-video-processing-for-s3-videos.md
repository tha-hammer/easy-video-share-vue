<!-- Generated by SpecStory -->

# Plan video processing for S3 videos (2025-07-06 13:11Z)

_**User**_

Next, I want you to help me plan a way to use videos that are already on S3 for processing.

The user should have a button in the 'My Video' view that says "Make Segments". On click the app should process the video using the existing video processing steps, the only change being the 'upload video' step is not needed.  Help me plan first.

---

_**Assistant**_

I'll help you plan a way to process videos that are already on S3. Let me first explore the current codebase to understand the existing video processing flow and the "My Video" view.


---

<details>
            <summary>Searched codebase "My Video view component" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/views/Videos.vue` | L102-131 |
| `src/components/video/VideoPlayerModal.vue` | L1-47 |
| `src/views/VideoSegmentView.vue` | L201-232 |
| `src/views/VideoSegmentView.vue` | L232-290 |
| `src/views/Videos.vue` | L223-263 |
| `src/components/admin/AdminVideosPanel.vue` | L166-185 |
| `src/components/video/VideoModal.vue` | L27-70 |
| `src/components/video/VideoCard.vue` | L59-104 |
| `src/components/admin/AdminUserVideosPanel.vue` | L207-225 |
| `src/components/video/VideoModal.vue` | L164-223 |
| `src/views/Videos.vue` | L131-175 |
| `src/components/video/UniversalVideoPlayer.vue` | L44-88 |
| `src/components/admin/AdminVideosPanel.vue` | L76-98 |
| `src/components/admin/AdminUserVideosPanel.vue` | L128-147 |
| `src/components/video/VideoCard.vue` | L1-59 |
| `src/views/Videos.vue` | L1-50 |
| `src/components/video/UniversalVideoPlayer.vue` | L378-416 |
| `src/views/Videos.vue` | L318-366 |
| `src/components/video/VideoPlayerModal.vue` | L79-147 |
| `src/components/video/VideoModal.vue` | L100-138 |
| `src/components/admin/AdminOverviewPanel.vue` | L169-218 |
| `src/components/video/VideoPlayerModal.vue` | L147-211 |
| `src/views/Processing.vue` | L75-126 |
| `src/components/video/VideoCard.vue` | L104-159 |
| `src/components/admin/AdminVideosPanel.vue` | L1-33 |

</details>

---

Now let me look at the current video processing flow to understand how videos are processed:


---

<details>
            <summary>Searched codebase "video processing upload flow backend API" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `backend/main.py` | L433-469 |
| `backend/main_no_redis.py` | L30-64 |
| `backend/real_upload_test.py` | L58-110 |
| `backend/main.py` | L310-358 |
| `MULTIPART_UPLOAD_IMPLEMENTATION.md` | L95-174 |
| `backend/main.py` | L264-310 |
| `backend/e2e_full_workflow_test.py` | L20-43 |
| `src/composables/useVideoUpload.ts` | L700-747 |
| `src/core/services/VideoService.ts` | L1-22 |
| `backend/main.py` | L386-433 |
| `backend/main.py` | L231-264 |
| `backend/tasks.py` | L75-126 |
| `src/core/services/VideoService.ts` | L344-384 |
| `backend/main.py` | L142-197 |
| `src/composables/useVideoUpload.ts` | L790-822 |
| `src/core/config/config.ts` | L45-58 |
| `backend/test_complete_upload.py` | L19-69 |
| `src/views/Upload.vue` | L889-945 |
| `src/core/services/VideoService.ts` | L300-344 |
| `backend/models.py` | L114-129 |
| `src/stores/videos.ts` | L17-86 |
| `src/views/Upload.vue` | L945-975 |
| `backend/main_no_redis.py` | L64-92 |
| `backend/models.py` | L44-51 |
| `src/composables/useVideoUpload.ts` | L579-634 |

</details>

---

Now let me look at the current video processing task to understand how it works:


---

Read file: backend/tasks.py

---

Now let me check the VideoCard component to see the current actions available:


---

Read file: src/components/video/VideoCard.vue

---

Now let me check the backend API to see if there's already an endpoint for processing existing videos:


---

<details>
            <summary>Grep search for "process.*existing.*video" • **0** files</summary>
        
No results found
</details>

---

<details>
            <summary>Grep search for "make.*segments" • **0** files</summary>
        
No results found
</details>

---

Let me check the backend models to understand the current data structures:


---

Read file: backend/models.py

---

Now let me check the current video processing flow to understand how it works:


---

<details>
            <summary>Searched codebase "process_video_task cutting_options text_strategy" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `backend/tasks.py` | L126-168 |
| `backend/tasks.py` | L75-126 |
| `backend/tasks.py` | L35-75 |
| `backend/tasks.py` | L168-207 |
| `backend/tasks.py` | L256-290 |
| `backend/test_base_vary_manual.py` | L1-50 |
| `backend/main.py` | L386-433 |
| `backend/test_unique_for_all_manual.py` | L1-50 |
| `backend/main.py` | L264-310 |
| `backend/tasks.py` | L207-256 |
| `backend/manual_test_base_vary.py` | L1-60 |
| `backend/video_processing_utils_sprint4.py` | L1-59 |
| `backend/manual_test_unique_for_all.py` | L1-64 |
| `backend/models.py` | L114-129 |
| `backend/test_multiline_celery.py` | L86-134 |
| `backend/video_processing_utils_sprint4.py` | L59-90 |
| `backend/video_processing_utils_sprint4.py` | L90-128 |
| `backend/video_processing_utils.py` | L1-43 |
| `src/views/Upload.vue` | L889-945 |
| `backend/video_processing_utils_sprint4.py` | L128-172 |
| `Ai-BRoll-Short-Form-Video-Generation-Plan.md` | L80-94 |
| `backend/test_multiline_celery.py` | L1-59 |
| `backend/video_processing_utils_sprint4.py` | L246-281 |
| `backend/models.py` | L90-108 |
| `backend/video_processing_utils.py` | L89-127 |

</details>

---

Based on my analysis of the codebase, I can now help you plan a way to process videos that are already on S3. Here's a comprehensive plan:

## Plan: "Make Segments" Feature for Existing S3 Videos

### Overview
The goal is to add a "Make Segments" button to the "My Videos" view that allows users to process videos that are already uploaded to S3, skipping the upload step and going directly to the video processing workflow.

### Current State Analysis

**What exists:**
1. **Video Processing Pipeline**: The `process_video_task` Celery task already handles video processing with cutting options and text strategies
2. **Video Display**: The "My Videos" view shows uploaded videos with metadata
3. **Processing Flow**: Upload → Complete → Process workflow is established
4. **Video Card Actions**: Currently has Play, Segments (if processed), Share, and Delete buttons

**What's missing:**
1. **Re-processing Endpoint**: No API endpoint to process existing videos
2. **UI Integration**: No "Make Segments" button for unprocessed videos
3. **Processing Configuration**: No way to specify cutting options and text strategy for existing videos

### Implementation Plan

#### 1. Backend API Changes

**New Endpoint: `/api/videos/{video_id}/process`**
```python
@router.post("/videos/{video_id}/process", response_model=JobCreatedResponse)
async def process_existing_video(
    video_id: str,
    request: ProcessExistingVideoRequest
) -> JobCreatedResponse:
    """
    Process an existing video that's already on S3
    
    This endpoint allows users to create segments from videos that were
    previously uploaded but not processed, or to re-process videos with
    different settings.
    """
```

**New Request Model:**
```python
class ProcessExistingVideoRequest(BaseModel):
    """Request model for processing existing videos"""
    cutting_options: Optional[CuttingOptions] = Field(None, description="Video cutting parameters")
    text_strategy: Optional[TextStrategy] = Field(None, description="Text overlay strategy")
    text_input: Optional[TextInput] = Field(None, description="Text content and context for overlay")
```

**Implementation Logic:**
1. Fetch video metadata from DynamoDB using `video_id`
2. Extract the `bucket_location` (S3 key) from the video metadata
3. Generate a new `job_id` for this processing job
4. Dispatch `process_video_task` with the existing S3 key
5. Create a new job entry in DynamoDB with status "QUEUED"
6. Return `JobCreatedResponse` with the new job ID

#### 2. Frontend Changes

**VideoCard Component Updates:**
- Add "Make Segments" button for videos that don't have `output_s3_urls` or have status other than "COMPLETED"
- Button should be disabled if video is currently being processed (status "PROCESSING" or "QUEUED")

**New Processing Modal:**
- Create a modal similar to the upload flow but without file upload
- Include cutting options configuration (fixed/random duration)
- Include text strategy selection (one_for_all, base_vary, unique_for_all)
- Include text input fields based on selected strategy

**Video Processing Service:**
- Add new method `processExistingVideo(videoId, options)` to `VideoService`
- Handle the API call to the new processing endpoint
- Integrate with existing progress tracking

#### 3. User Experience Flow

**Button States:**
1. **"Make Segments"** - For videos without segments
2. **"Re-process"** - For videos that already have segments
3. **"Processing..."** - When video is being processed
4. **"View Segments"** - For completed videos (existing)

**Processing Modal Flow:**
1. User clicks "Make Segments" button
2. Modal opens with processing options
3. User configures cutting options and text strategy
4. User clicks "Start Processing"
5. Modal closes, processing starts
6. User can track progress via existing progress system

#### 4. Technical Implementation Details

**Backend Changes:**

1. **New API Endpoint** (`main.py`):
```python
@router.post("/videos/{video_id}/process", response_model=JobCreatedResponse)
async def process_existing_video(video_id: str, request: ProcessExistingVideoRequest):
    # Get video metadata
    video_metadata = dynamodb_service.get_job_status(video_id)
    if not video_metadata:
        raise HTTPException(status_code=404, detail="Video not found")
    
    # Generate new job ID for this processing run
    new_job_id = str(uuid.uuid4())
    
    # Get S3 key from existing video
    s3_key = video_metadata.get("bucket_location")
    if not s3_key:
        raise HTTPException(status_code=400, detail="Video S3 location not found")
    
    # Dispatch processing task
    task = process_video_task.delay(
        s3_input_key=s3_key,
        job_id=new_job_id,
        cutting_options=request.cutting_options.dict() if request.cutting_options else None,
        text_strategy=request.text_strategy.value if request.text_strategy else None,
        text_input=request.text_input.dict() if request.text_input else None,
        user_id=video_metadata.get("user_id", "anonymous")
    )
    
    # Create new job entry
    dynamodb_service.create_job_entry(
        job_id=new_job_id,
        user_id=video_metadata.get("user_id"),
        upload_date=datetime.utcnow().isoformat(),
        status="QUEUED",
        # ... other metadata
    )
    
    return JobCreatedResponse(
        job_id=new_job_id,
        status="QUEUED",
        message="Video processing job has been queued successfully"
    )
```

2. **New Request Model** (`models.py`):
```python
class ProcessExistingVideoRequest(BaseModel):
    cutting_options: Optional[CuttingOptions] = None
    text_strategy: Optional[TextStrategy] = None
    text_input: Optional[TextInput] = None
```

**Frontend Changes:**

1. **VideoCard Component** - Add "Make Segments" button:
```vue
<button
  v-if="!video.output_s3_urls || video.output_s3_urls.length === 0 || video.status !== 'COMPLETED'"
  class="btn btn-sm btn-light-warning"
  @click="$emit('make-segments', video)"
  :disabled="video.status === 'PROCESSING' || video.status === 'QUEUED'"
  title="Make segments"
>
  <KTIcon icon-name="scissors" icon-class="fs-4" />
  {{ video.status === 'PROCESSING' || video.status === 'QUEUED' ? 'Processing...' : 'Make Segments' }}
</button>
```

2. **New Processing Modal Component**:
```vue
<!-- ProcessVideoModal.vue -->
<template>
  <div class="modal fade show d-block" v-if="isVisible">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Process Video: {{ video?.title }}</h5>
          <button type="button" class="btn-close" @click="closeModal"></button>
        </div>
        <div class="modal-body">
          <!-- Cutting Options -->
          <div class="mb-4">
            <h6>Cutting Options</h6>
            <!-- Same cutting options UI as upload flow -->
          </div>
          
          <!-- Text Strategy -->
          <div class="mb-4">
            <h6>Text Overlay</h6>
            <!-- Same text strategy UI as upload flow -->
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" @click="closeModal">Cancel</button>
          <button type="button" class="btn btn-primary" @click="startProcessing" :disabled="processing">
            {{ processing ? 'Processing...' : 'Start Processing' }}
          </button>
        </div>
      </div>
    </div>
  </div>
</template>
```

3. **VideoService Updates**:
```typescript
// Add to VideoService.ts
static async processExistingVideo(
  videoId: string,
  options: {
    cutting_options?: any;
    text_strategy?: string;
    text_input?: any;
  }
): Promise<JobCreatedResponse> {
  const response = await fetch(`${API_CONFIG.aiVideoBackend}/api/videos/${videoId}/process`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(options)
  });
  
  if (!response.ok) {
    throw new Error(`Failed to process video: ${response.statusText}`);
  }
  
  return response.json();
}
```

#### 5. Integration Points

**Progress Tracking:**
- Use existing SSE progress tracking system
- Redirect to processing view after starting processing
- Show progress updates in real-time

**Error Handling:**
- Handle cases where video metadata is missing
- Handle cases where S3 key is invalid
- Provide user-friendly error messages

**State Management:**
- Update video status in the store after processing starts
- Refresh video list after processing completes
- Handle loading states appropriately

### Benefits of This Approach

1. **Reuses Existing Infrastructure**: Leverages the existing video processing pipeline
2. **Consistent UX**: Uses the same processing options and progress tracking
3. **Flexible**: Allows re-processing with different settings
4. **Efficient**: No need to re-upload videos
5. **Scalable**: Uses existing Celery task system

### Implementation Priority

1. **Phase 1**: Backend API endpoint and models
2. **Phase 2**: Frontend modal and service integration
3. **Phase 3**: VideoCard component updates
4. **Phase 4**: Testing and error handling
5. **Phase 5**: UI polish and user experience improvements

This plan provides a clean, maintainable way to add the "Make Segments" functionality while reusing as much existing code as possible. Would you like me to start implementing any specific part of this plan?

---

